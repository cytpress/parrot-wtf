<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D 座標驗證</title>
<style>
    /* ... (大部分 CSS 保持不變) ... */
    body, html { height: 100%; margin: 0; overflow: hidden; }
    body {
        font-family: sans-serif;
        background-color: #222;
        color: #eee;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .controls {
        margin-bottom: 10px; /* Reduced margin */
        padding: 10px;
        background-color: #333;
        border-radius: 5px;
        text-align: center;
        flex-shrink: 0;
        position: relative; /* For z-index if needed */
        z-index: 10;
    }
    .controls p { margin: 5px 0; font-size: 0.9em; }
    .controls label { margin-right: 5px; }
    .controls input[type="range"] { width: 120px; vertical-align: middle; }
    .controls button {
        padding: 5px 10px; background-color: #555; color: white;
        border: none; border-radius: 3px; cursor: pointer; margin-left: 10px;
    }
    .controls button:hover { background-color: #666; }

    #scene-viewport {
        width: 80vw; height: 70vh;
        max-width: 800px; max-height: 600px;
        border: 1px solid #555;
        perspective: 1000px;
        background-color: #1a1a1a;
        overflow: hidden;
        position: relative;
        cursor: grab;
    }

    #camera-rig {
        width: 100%; height: 100%;
        transform-style: preserve-3d;
        position: absolute;
    }

    #scene {
        width: 1px; height: 1px;
        transform-style: preserve-3d;
        position: absolute;
        transform-origin: 0 0 0;
        top: 50%;
        left: 50%;
    }

    .block {
        position: absolute;
        transform-style: preserve-3d;
        font-size: 10px;
        user-select: none;
        /* Add transition for smoother highlight */
        /* transition: transform 0.1s ease-out; */ /* Can cause issues with rapid mouse movements */
    }
    .block:hover {
        /* Optional: highlight on hover, e.g., slightly scale or change border
           Be careful as this can affect performance or cause visual jitter */
        /* transform: scale3d(1.2, 1.2, 1.2); */
    }


    .block .face {
        position: absolute;
        width: 100%; height: 100%;
        box-sizing: border-box;
        border: 1px solid rgba(0, 0, 0, 0.5);
        opacity: 0.85;
        backface-visibility: hidden;
    }
    /* ... (face colors and transforms unchanged) ... */
    .block-type-z .face { background-color: #ff6b6b; }
    .block-type-O .face { background-color: #feca57; }
    .block-type-y .face { background-color: #48dbfb; } /* This is for data type 'y' */
    .block-type-xy .face { background-color: #1dd1a1; }
    .block-type-x .face { background-color: #ff9ff3; }
    .block-type-yz .face { background-color: #54a0ff; }
    .block-type-xz .face { background-color: #c8d6e5; }
    .block-type-empty .face { background-color: #8395a7; }
    .block-type-unknown .face { background-color: #576574; }

    .block .front  { transform: rotateY(  0deg) translateZ(var(--half-size)); }
    .block .back   { transform: rotateY(180deg) translateZ(var(--half-size)); }
    .block .right  { transform: rotateY( 90deg) translateZ(var(--half-size)); }
    .block .left   { transform: rotateY(-90deg) translateZ(var(--half-size)); }
    .block .top    { transform: rotateX( 90deg) translateZ(var(--half-size)); }
    .block .bottom { transform: rotateX(-90deg) translateZ(var(--half-size)); }


    .axis { /* ... unchanged ... */
        position: absolute;
        transform-origin: 0 50%;
        height: 3px;
    }
    .axis-x-positive { background-color: red; }
    .axis-y-positive { background-color: green; }
    .axis-z-positive { background-color: blue; }

    .axis-label { /* ... unchanged ... */
        position: absolute;
        color: white;
        font-size: 16px;
        font-weight: bold;
        user-select: none;
    }

    #tooltip {
        position: fixed; /* Or absolute relative to a container */
        bottom: 10px;
        left: 10px;
        background-color: rgba(0,0,0,0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
        pointer-events: none; /* So it doesn't interfere with mouse events on blocks */
        z-index: 100;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
    }
    #tooltip.visible {
        opacity: 1;
    }

</style>
</head>
<body>
<h1>3D 座標視覺化器</h1>
<div class="controls">
    <p>左鍵拖拽：旋轉 | 空白鍵 + 左鍵拖拽：平移 | 滑鼠滾輪：縮放</p>
    <div>
        <label for="blockSize">方塊大小:</label>
        <input type="range" id="blockSize" min="5" max="50" value="20">
        <span id="blockSizeValue">20px</span>
    </div>
     <div>
        <label for="spacing">間距因子:</label>
        <input type="range" id="spacing" min="10" max="80" value="30">
        <span id="spacingValue">30</span>
    </div>
    <button id="resetView">重置視圖</button>
</div>

<div id="scene-viewport">
    <div id="camera-rig">
        <div id="scene">
            <!-- Dynamic content here -->
        </div>
    </div>
</div>
<div id="tooltip">Hover over a block to see its info.</div>

<script>
const dataString = `
block ID	x	y	z	/
1	0	0	5	
2	0	2	3	z
3	0	6	1	O
4	0	9	4	y
5	1	1	13	xy
6	1	1	16	z
7	1	3	8	x
8	1	6	8	x
9	1	6	15	xy
10	1	7	12	O
11	1	7	13	xy
12	1	8	7	xy
13	1	9	2	xy
14	1	9	4	yz
15	1	11	3	z
16	1	12	16	O
17	2	0	8	z
18	2	2	11	z
19	2	4	14	xy
20	2	4	14	xz
21	2	5	1	
22	2	5	4	x
23	2	6	12	O
24	2	9	10	yz
25	2	10	8	
26	2	13	5	z
27	2	14	9	z
28	3	1	3	yz
29	3	3	9	O
30	3	3	15	xy
31	3	5	1	xz
32	3	5	3	O
33	3	10	6	yz
34	3	11	16	
35	3	12	1	O
36	3	15	4	O
37	3	15	9	xy
38	4	1	6	
39	4	2	4	
40	4	2	11	y
41	4	4	4	xy
42	4	4	15	z
43	4	10	11	yz
44	4	11	12	O
45	4	14	8	xy
46	5	0	9	
47	5	2	6	y
48	5	3	1	yz
49	5	3	12	z
50	5	5	11	O
51	5	5	13	
52	5	10	0	O
53	5	11	5	yz
54	5	13	14	xy
55	6	0	4	z
56	6	1	6	yz
57	6	1	7	xz
58	6	2	9	O
59	6	2	15	xz
60	6	6	6	xy
61	6	6	9	O
62	6	9	5	z
63	6	11	8	y
64	6	12	12	
65	7	1	15	O
66	7	3	5	xz
67	7	5	9	
68	7	7	3	xy
69	7	7	12	z
70	7	8	13	z
71	7	11	16	xy
72	8	4	6	
73	8	4	15	x
74	8	5	14	xz
75	8	7	15	O
76	8	8	1	
77	8	8	7	z
78	8	10	9	xy
79	9	3	0	
80	9	6	2	x
81	9	7	4	O
82	9	9	0	
83	10	6	10	O
84	10	7	5	x
85	10	8	2	xy
86	11	5	14	O
87	11	7	12	
88	12	3	1	xy
89	12	4	3	O
90	12	6	5	
91	13	3	16	xy
92	13	4	5	z
93	13	5	14	xy
94	14	3	8	z
95	14	3	16	xy
96	14	4	4	
97	15	2	11	z
98	15	3	12	
`;

const sceneElement = document.getElementById('scene');
const cameraRig = document.getElementById('camera-rig');
const sceneViewport = document.getElementById('scene-viewport');
const blockSizeSlider = document.getElementById('blockSize');
const blockSizeValueDisplay = document.getElementById('blockSizeValue');
const spacingSlider = document.getElementById('spacing');
const spacingValueDisplay = document.getElementById('spacingValue');
const resetButton = document.getElementById('resetView');
const tooltipElement = document.getElementById('tooltip'); // Get the tooltip element

let blocksData = [];
let dataBounds = null;
let currentBlockSize = parseInt(blockSizeSlider.value);
let currentSpacingFactor = parseInt(spacingSlider.value);

// Restore initial rotations if centering is good
const INITIAL_ROTATION_X = -30;
const INITIAL_ROTATION_Y = 30;
// const INITIAL_ROTATION_X = 0; // Use for testing centering
// const INITIAL_ROTATION_Y = 0;

const INITIAL_CAMERA_X = 0;
const INITIAL_CAMERA_Y = 0;

let rotationX = INITIAL_ROTATION_X;
let rotationY = INITIAL_ROTATION_Y;
let cameraTranslateX = INITIAL_CAMERA_X;
let cameraTranslateY = INITIAL_CAMERA_Y;
let cameraTranslateZ = 0;


function parseData(dataStr) {
    const lines = dataStr.trim().split('\n');
    const headers = lines[0].split('\t').map(h => h.trim());
    const data = [];
    let minX = Infinity, minY = Infinity, minZ = Infinity;
    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split('\t');
        if (values.length < 4) continue; // Ensure at least ID, x, y, z are present

        // Parse original coordinates
        let originalX = parseInt(values[1].trim());
        let originalY = parseInt(values[2].trim());
        let originalZ = parseInt(values[3].trim());
        const type = (values[4] || "").trim(); // Get type, default to empty string if not present

        if (isNaN(originalX) || isNaN(originalY) || isNaN(originalZ)) continue; // Skip if coords are not numbers

        // Initialize final coordinates with original values
        let finalX = originalX;
        let finalY = originalY;
        let finalZ = originalZ;

        // Apply symmetry transformations based on type
        // The type string indicates which coordinates to negate
        if (type.includes('x')) {
            finalX = -originalX;
        }
        if (type.includes('y')) {
            finalY = -originalY;
        }
        if (type.includes('z')) {
            finalZ = -originalZ;
        }
        // Special case for 'O' (origin symmetry), which implies xyz
        // This also correctly handles if type was "O" and also, for some reason, "Ox", "Oy", "Oz", etc.
        // Though typically 'O' would stand alone.
        // If 'O' is strictly 'xyz' and nothing else, a direct check is fine:
        if (type === 'O') {
            finalX = -originalX;
            finalY = -originalY;
            finalZ = -originalZ;
        }
        // Note: If type is, for example, "xy", the includes('x') and includes('y') will correctly negate both.

        const block = {
            id: parseInt(values[0].trim()),
            x: finalX, // Use the transformed x-coordinate
            y: finalY, // Use the transformed y-coordinate
            z: finalZ, // Use the transformed z-coordinate
            type: type  // Keep the original type for styling/coloring
        };

        data.push(block);

        // Update bounds using the FINAL (transformed) coordinates
        minX = Math.min(minX, block.x);
        minY = Math.min(minY, block.y);
        minZ = Math.min(minZ, block.z);
        maxX = Math.max(maxX, block.x);
        maxY = Math.max(maxY, block.y);
        maxZ = Math.max(maxZ, block.z);
    }
    dataBounds = { minX, minY, minZ, maxX, maxY, maxZ };
    return data;
}

function createBlocks(blocks) {
    sceneElement.innerHTML = ''; // Clear previous blocks and axes if axes are inside sceneElement
    if (!dataBounds || blocks.length === 0) return;
    const { minX, minY, minZ, maxX, maxY, maxZ } = dataBounds;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    const centerZ = (minZ + maxZ) / 2;

    blocks.forEach(blockData => {
        const blockElement = document.createElement('div');
        blockElement.classList.add('block');
        
        // Store ALL relevant original data in dataset for tooltip
        blockElement.dataset.blockId = blockData.id;
        blockElement.dataset.blockX = blockData.x;
        blockElement.dataset.blockY = blockData.y;
        blockElement.dataset.blockZ = blockData.z;
        blockElement.dataset.blockType = blockData.type || 'N/A';

        // Store calculated center (used by applyBlockTransform)
        blockElement.dataset.centerX = centerX;
        blockElement.dataset.centerY = centerY;
        blockElement.dataset.centerZ = centerZ;
        
        let typeClass = 'block-type-unknown';
        if (blockData.type === '') typeClass = 'block-type-empty';
        else if (['z', 'O', 'y', 'xy', 'x', 'yz', 'xz'].includes(blockData.type)) {
            typeClass = `block-type-${blockData.type}`;
        }
        blockElement.classList.add(typeClass);

        const faces = ['front', 'back', 'left', 'right', 'top', 'bottom'];
        faces.forEach(faceName => {
            const faceDiv = document.createElement('div');
            faceDiv.classList.add('face', faceName);
            blockElement.appendChild(faceDiv);
        });

        // Add event listeners for tooltip
        blockElement.addEventListener('mouseover', handleBlockMouseOver);
        blockElement.addEventListener('mouseout', handleBlockMouseOut);
        
        applyBlockTransform(blockElement, currentBlockSize, currentSpacingFactor);
        sceneElement.appendChild(blockElement);
    });
}

function handleBlockMouseOver(event) {
    const blockElement = event.currentTarget;
    tooltipElement.innerHTML = `ID: ${blockElement.dataset.blockId}<br>
                                X: ${blockElement.dataset.blockX}<br>
                                Y: ${blockElement.dataset.blockY} (Depth)<br>
                                Z: ${blockElement.dataset.blockZ} (Height)<br>
                                Type: ${blockElement.dataset.blockType}`;
    tooltipElement.classList.add('visible');
}

function handleBlockMouseOut() {
    tooltipElement.classList.remove('visible');
}


function applyBlockTransform(blockElement, blockSize, spacingFactor) { /* ... unchanged ... */
    const x = parseFloat(blockElement.dataset.blockX), // Use the stored raw data
          y = parseFloat(blockElement.dataset.blockY),
          z = parseFloat(blockElement.dataset.blockZ);
    const centerX = parseFloat(blockElement.dataset.centerX),
          centerY = parseFloat(blockElement.dataset.centerY),
          centerZ = parseFloat(blockElement.dataset.centerZ);
    
    const adjustedX = (x - centerX) * spacingFactor;
    const adjustedY = (y - centerY) * spacingFactor; 
    const adjustedZ = (z - centerZ) * spacingFactor; 

    blockElement.style.setProperty('--half-size', `${blockSize / 2}px`);
    blockElement.style.width = `${blockSize}px`;
    blockElement.style.height = `${blockSize}px`;
    
    const cssX = adjustedX;
    const cssY = -adjustedZ; 
    const cssZ = adjustedY;  // Positive Data Y is positive Visual Z (towards viewer)
    blockElement.style.transform = `translate3d(${cssX}px, ${cssY}px, ${cssZ}px)`;
}

function updateAllBlockTransformsAndAxes() { /* ... unchanged ... */
    const blockElements = sceneElement.querySelectorAll('.block');
    blockElements.forEach(blockEl => {
        applyBlockTransform(blockEl, currentBlockSize, currentSpacingFactor);
    });
    createOrUpdateAxes();
}

function calculateOptimalZoomZ() { /* ... unchanged ... */
    if (!dataBounds) return 0;
    const { minX, minY, minZ, maxX, maxY, maxZ } = dataBounds;
    const spanXUnits = maxX - minX + 1;
    const spanYUnits = maxY - minY + 1;
    const spanZUnits = maxZ - minZ + 1;
    const scaledSpanX = spanXUnits * currentSpacingFactor;
    const scaledSpanDepth = spanYUnits * currentSpacingFactor;
    const scaledSpanHeight = spanZUnits * currentSpacingFactor;
    const modelExtentX = scaledSpanX + currentBlockSize;
    const modelExtentDepth = scaledSpanDepth + currentBlockSize;
    const modelExtentHeight = scaledSpanHeight + currentBlockSize;
    const modelMaxSpan = Math.max(modelExtentX, modelExtentDepth, modelExtentHeight);
    const viewportMinDim = Math.min(sceneViewport.clientWidth, sceneViewport.clientHeight);
    const perspectiveValue = parseFloat(getComputedStyle(sceneViewport).perspective);
    if (modelMaxSpan === 0 || viewportMinDim === 0 || !perspectiveValue) return -300;
    const fillFactor = 0.75;
    let autoZoomZ = perspectiveValue * (1 - modelMaxSpan / (viewportMinDim * fillFactor));
    autoZoomZ = Math.min(autoZoomZ, -modelMaxSpan * 0.8); 
    return autoZoomZ;
}

function createOrUpdateAxes() { // Ensure Y (Depth) label is correct
    let axesContainer = sceneElement.querySelector('#axes-container');
    if (!axesContainer) {
        axesContainer = document.createElement('div');
        axesContainer.id = 'axes-container';
        axesContainer.style.transformStyle = 'preserve-3d';
        sceneElement.appendChild(axesContainer);
    }
    axesContainer.innerHTML = '';

    if (!dataBounds) return;
    const { minX, minY, minZ, maxX, maxY, maxZ } = dataBounds;
    const modelSpanX = (maxX - minX + 1) * currentSpacingFactor;
    const modelSpanDataY = (maxY - minY + 1) * currentSpacingFactor;
    const modelSpanDataZ = (maxZ - minZ + 1) * currentSpacingFactor;
    const axisBaseLength = Math.max(modelSpanX, modelSpanDataY, modelSpanDataZ, 100) * 0.6;

    // Visual X (Data X) - Red
    // Visual Y (Data Z - Height) - Green
    // Visual Z (Data Y - Depth) - Blue. Positive Visual Z is towards viewer.
    const axesDefinitions = [
        { name: 'X', className: 'axis-x-positive', color: 'red',
          transform: `translateY(-1.5px)`,
          labelTransform: `translateX(${axisBaseLength + 15}px) translateY(-8px)` },
        { name: 'Z (Height)', className: 'axis-y-positive', color: 'green',
          transform: `translateX(-1.5px) rotateZ(-90deg)`,
          labelTransform: `translateY(-${axisBaseLength + 25}px) translateX(-30px)` },
        // Blue line (Visual Z, Data Y) extends towards viewer (positive CSS Z)
        { name: 'Y (Depth)', className: 'axis-z-positive', color: 'blue',
          transform: `translateX(-1.5px) rotateY(-90deg)`,
          // Label should be at the positive end of this visual Z axis
          labelTransform: `translateZ(${axisBaseLength + 15}px) translateX(-30px) translateY(-8px)` }
    ];

    axesDefinitions.forEach(ax => {
        const line = document.createElement('div');
        line.classList.add('axis', ax.className);
        line.style.width = `${axisBaseLength}px`;
        line.style.transform = ax.transform;
        axesContainer.appendChild(line);

        const label = document.createElement('div');
        label.classList.add('axis-label');
        label.textContent = ax.name;
        label.style.color = window.getComputedStyle(line).backgroundColor || ax.color;
        label.style.transform = ax.labelTransform;
        axesContainer.appendChild(label);
    });
}


function applySceneTransforms() { /* ... unchanged ... */
    cameraRig.style.transform = `translateX(${cameraTranslateX}px) translateY(${cameraTranslateY}px) translateZ(${cameraTranslateZ}px)`;
    sceneElement.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;
}

// --- Interaction Logic (unchanged) ---
// ...
let isDragging = false, currentAction = null, previousMouseX, previousMouseY, isSpacebarPressed = false;
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && !isSpacebarPressed) {
        e.preventDefault(); isSpacebarPressed = true;
        if (isDragging && currentAction === 'rotate') { currentAction = 'pan'; sceneViewport.style.cursor = 'move'; }
        else if (!isDragging) { sceneViewport.style.cursor = 'move'; }
    }
});
document.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
        e.preventDefault(); isSpacebarPressed = false;
        if (isDragging && currentAction === 'pan') { currentAction = 'rotate'; sceneViewport.style.cursor = 'grabbing'; }
        else if (!isDragging) { sceneViewport.style.cursor = 'grab'; }
    }
});
sceneViewport.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return; isDragging = true;
    previousMouseX = e.clientX; previousMouseY = e.clientY;
    currentAction = isSpacebarPressed ? 'pan' : 'rotate';
    sceneViewport.style.cursor = currentAction === 'pan' ? 'move' : 'grabbing';
});
document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const deltaX = e.clientX - previousMouseX, deltaY = e.clientY - previousMouseY;
    if (currentAction === 'rotate') {
        rotationY += deltaX * 0.5; rotationX -= deltaY * 0.5;
        rotationX = Math.max(-90, Math.min(90, rotationX));
    } else if (currentAction === 'pan') {
        const panSensitivity = 1.0;
        cameraTranslateX += deltaX * panSensitivity;
        cameraTranslateY += deltaY * panSensitivity;
    }
    applySceneTransforms();
    previousMouseX = e.clientX; previousMouseY = e.clientY;
});
document.addEventListener('mouseup', (e) => {
    if (e.button !== 0) return;
    if (isDragging) { isDragging = false; sceneViewport.style.cursor = isSpacebarPressed ? 'move' : 'grab'; }
});
sceneViewport.addEventListener('wheel', (e) => {
    e.preventDefault(); const zoomIntensity = 0.5;
    const scrollAmount = e.deltaY > 0 ? -100 : 100;
    cameraTranslateZ += scrollAmount * zoomIntensity;
    applySceneTransforms();
});

// --- Controls (unchanged) ---
// ...
blockSizeSlider.addEventListener('input', (e) => {
    currentBlockSize = parseInt(e.target.value);
    blockSizeValueDisplay.textContent = `${currentBlockSize}px`;
    updateAllBlockTransformsAndAxes();
});
spacingSlider.addEventListener('input', (e) => {
    currentSpacingFactor = parseInt(e.target.value);
    spacingValueDisplay.textContent = currentSpacingFactor;
    updateAllBlockTransformsAndAxes();
});
resetButton.addEventListener('click', () => {
    rotationX = INITIAL_ROTATION_X; rotationY = INITIAL_ROTATION_Y;
    cameraTranslateX = INITIAL_CAMERA_X; cameraTranslateY = INITIAL_CAMERA_Y;
    cameraTranslateZ = calculateOptimalZoomZ();
    applySceneTransforms();
    createOrUpdateAxes();
});

// --- Initialization ---
blocksData = parseData(dataString);
createBlocks(blocksData); // This now also adds event listeners for tooltip
createOrUpdateAxes();
cameraTranslateZ = calculateOptimalZoomZ();
applySceneTransforms();

// Remove originMarker if no longer needed for debugging
const originMarker = sceneElement.querySelector('#originMarker');
if (originMarker) {
    originMarker.remove(); // Clean up if it exists from previous runs
}
// To add it again for debugging:
/*
const debugMarker = document.createElement('div');
debugMarker.id = 'originMarker'; // Give it an ID for potential removal
debugMarker.style.width = '10px';
debugMarker.style.height = '10px';
debugMarker.style.background = 'magenta';
debugMarker.style.position = 'absolute';
debugMarker.style.transform = 'translate3d(-5px, -5px, -5px)';
sceneElement.appendChild(debugMarker);
*/

</script>
</body>
</html>